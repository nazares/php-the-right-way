---
title: Комплексная проблема
isChild: true
anchor:  complex_problem
---

## Комплексная проблема {#complex_problem_title}

Если вы когда либо читали о Внедрении зависимости, то вероятнее всего знакомы с терминами *"Инверсия управления"* или
*"Принцип инверсии зависимостей"*. These are the complex problems that Dependency Injection solves.

### Инверсия управления

Инверсия управления как говорится, "инвертирует управление" системы, сохраняя организационное управление полноценно
отделяясь от наших объектов. В терминологии Инверсии управления, означает потерю наших зависимостей управляя и реализуя
их где либо в системе.

На протяжении нескольких лет, PHP фреймворками была достигнута Инверсия Управления, однако, стоял вопрос, какую часть
управления мы инвертируем, и где? Например, MVC фреймворки обычно предоставляют супер объект или, основной контроллер
которые другие контроллеры должны расширять, получая доступ к их зависимостям. Это **и есть** Инверсия управления, однако,
вместо потери зависимостей, этот метод просто перемещает их.

Внедрение зависимости позволяет нам более элегантно решить эту проблему, внедряя нужные зависимости, только тогда, когда
мы нуждаемся в них, без необходимости сложных зависимостей вообще.

### S.O.L.I.D

#### Принцип единственной ответственности

Принцип единственной ответственности об актерах и высокоуровневой архитектуре. Это состояние когда “Класс A должен иметь
только одну причину для изменения.” Это значит, что каждый класс должен иметь ответственность *только* над одной частью
функциональности предоставляемой ПО. Огромнейшая польза от этого подхода в том что он включает *переиспользование*
улучшенного кода. Спроектировав наш класс для выполнения только одной задачи, мы можем использовать (или переиспользовать)
его в любой другой программе, не изменяя.

#### Принцип Открытости/Закрытости

Принцип открытости/закрытости касается проектирования классов и расширений функций. В нем говорится, что "программные
объекты (классы, модули, функции и т. д.) должны быть открыты для расширения, но закрыты для модификации". Это означает,
что мы должны проектировать наши модули, классы и функции таким образом, чтобы, когда потребуется новая функциональность,
мы не должны были изменять наш существующий код, а скорее писать новый код, который будет использоваться существующим
кодом. С практической точки зрения это означает, что мы должны писать классы, которые реализуют *интерфейсы* и
придерживаются их, а затем указывать тип для этих интерфейсов, а не для конкретных классов.

Самым большим преимуществом этого подхода является то, что мы можем очень легко расширить наш код с поддержкой чего-то
нового, не изменяя существующий код, а это означает, что мы можем сократить время контроля качества, а риск негативного
воздействия на приложение существенно снижается. Мы можем развертывать новый код быстрее и с большей уверенностью.

#### Принцип замены Лисков

Принцип замены Лисков касается подтипов и наследования. В нем говорится, что "дочерние классы никогда не должны нарушать
определения типов родительского класса". Или, говоря словами Robert C. Martin, "подтипы должны быть взаимозаменяемыми для
своих базовых типов".

Например, если у нас есть интерфейс `FileInterface`, который определяет метод `embed()`, и у нас есть классы `Audio` и
`Video`, которые оба реализуют интерфейс `FileInterface`, то мы можем ожидать, что использование Метод `embed()` всегда
будет делать то, что мы намеревались. Если позже мы создадим класс `PDF` или класс `Gist`, которые реализуют интерфейс
`FileInterface`, мы уже будем знать и понимать, что будет делать метод `embed()`. Самым большим преимуществом этого
подхода является то, что у нас есть возможность создавать гибкие и легко настраиваемые программы, потому что, когда мы
меняем один объект типа (например, `FileInterface`) на другой, нам не нужно ничего менять в нашей программе.

#### Принцип разделения интерфейса

Принцип разделения интерфейса (ISP) касается связи *бизнес-логики с клиентами*. В нем говорится, что "Ни один клиент
не должен зависеть от методов, которые он не использует". Это означает, что вместо единого монолитного интерфейса,
который должны реализовать все соответствующие классы, мы должны вместо этого предоставить набор меньших интерфейсов,
зависящих от концепции, один или несколько из которых реализует соответствующий класс.

Например, классу `Car` или `Bus` будет интересен метод `SteeringWheel()`, а классу `Motorcycle` или `Tricycle` — нет.
И наоборот, классу `Motorcycle` или `Tricycle` будет интересен метод `handlebars()`, а классу `Car` или `Bus` — нет.
Нет необходимости, чтобы все эти типы транспортных средств поддерживали как `steeringWheel()`, так и `handlebars()`,
поэтому мы должны разделить исходный интерфейс.

#### Принцип инверсии зависимости

Принцип инверсии зависимостей заключается в удалении жестких ссылок между отдельными классами, чтобы можно было
использовать новые функции, передавая другой класс. В нем говорится, что нужно *"Зависеть от абстракций. Не зависеть от
конкретики"*. Проще говоря, это означает, что наши зависимости должны быть интерфейсами/контрактами или абстрактными
классами, а не конкретными реализациями. Мы можем легко реорганизовать приведенный выше пример, чтобы следовать этому
принципу.

{% highlight php %}
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct(AdapterInterface $adapter)
    {
        $this->adapter = $adapter;
    }
}

interface AdapterInterface {}

class MysqlAdapter implements AdapterInterface {}
{% endhighlight %}

Теперь у класса `Database` есть несколько преимуществ, зависящих от интерфейса, а не от конкретизации.

Учтите, что мы работаем в команде, а над адаптером работает коллега. В нашем первом примере нам
пришлось бы ждать, пока указанный коллега закончит работу над адаптером, прежде чем мы сможем должным образом смоделировать
его для наших модульных тестов. Теперь, когда зависимость представляет собой интерфейс/контракт, мы можем с радостью
создать макет этого интерфейса, зная, что наш коллега создаст адаптер на основе этого контракта.

Еще большее преимущество этого метода заключается в том, что наш код стал намного более масштабируемым. Если через год мы
решим, что хотим перейти на базу данных другого типа, мы можем написать адаптер, который реализует исходный интерфейс и
внедряет его вместо этого, больше не потребуется рефакторинг, поскольку мы можем гарантировать, что адаптер следует
контракт, установленный интерфейсом.
