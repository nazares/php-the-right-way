---
isChild: true
title: Ошибки
anchor:  errors
---

## Ошибки {#errors_title}

Во многих языках программирования с большим количеством исключений всякий раз, когда что-то пойдет не так, будет выдано
исключение. Это, безусловно, жизнеспособный способ сделать что-то, но PHP — это язык программирования с "легким
исключением". Хотя у него есть исключения, и большая часть ядра начинает использовать их при работе с объектами, большая
часть самого PHP будет пытаться продолжать обработку независимо от того, что происходит, если только не произойдет
фатальная ошибка.

Например:

{% highlight console %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

Это всего лишь ошибка уведомления, и PHP с радостью продолжит работу. Это может сбивать с толку тех, кто работает с
языками с "тяжелыми исключениями", потому что, например, ссылка на отсутствующую переменную в Python вызовет исключение:

{% highlight console %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

Единственная реальная разница в том, что Python сходит с ума из-за любой мелочи, так что разработчики могут быть уверены,
что любая потенциальная проблема или пограничный случай обнаружены, в то время как PHP продолжит обработку, если не
произойдет что-то экстремальное, и в этот момент он выдаст ошибку. ошибка и сообщите об этом.

### Серьезность ошибки

PHP имеет несколько уровней серьезности ошибок. Тремя наиболее распространенными типами сообщений являются ошибки,
уведомления и предупреждения. Они имеют разные уровни серьезности; `E_ERROR`, `E_NOTICE` и `E_WARNING`. Ошибки — это
фатальные ошибки во время выполнения, обычно они вызваны ошибками в вашем коде и должны быть исправлены, поскольку они
приводят к остановке выполнения PHP. Уведомления — это консультативные сообщения, вызванные кодом, который может вызывать
или не вызывать проблемы во время выполнения скрипта, выполнение не останавливается. Предупреждения являются не фатальными
ошибками, выполнение скрипта не будет остановлено.

Другим типом сообщений об ошибках, сообщаемых во время компиляции, являются сообщения `E_STRICT`. Эти сообщения
используются для предложения изменений в вашем коде, чтобы обеспечить наилучшее взаимодействие и совместимость с будущими
версиями PHP.

### Изменение поведения отчетов об ошибках PHP

Изменение поведения отчетов об ошибках PHP Отчеты об ошибках можно изменить с помощью настроек PHP и/или вызовов функций
PHP. Используя встроенную функцию PHP `error_reporting()`, вы можете установить уровень ошибок на время выполнения
скрипта, передав одну из предопределенных констант уровня ошибок, что означает, что если вы хотите видеть только ошибки
и предупреждения, но не уведомления - то вы можете настроить это:

{% highlight php %}
<?php
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

Вы также можете контролировать, будут ли ошибки отображаться на экране (удобно для разработки) или скрыты и
зарегистрированы (удобно для производства). Дополнительную информацию об этом можно найти в разделе [Отчеты об ошибках]
[errorreport].

### Встроенное подавление ошибок

Вы также можете указать PHP подавлять определенные ошибки с помощью оператора контроля ошибок `@`. Вы помещаете этот
оператор в начало выражения, и любая ошибка, являющаяся прямым результатом выражения, замалчивается.

{% highlight php %}
<?php
echo @$foo['bar'];
{% endhighlight %}

Это выведет `$foo['bar']`, если он существует, но просто вернет null и ничего не напечатает, если переменная `$foo` или
ключ `'bar'` не существует. Без оператора контроля ошибок это выражение могло бы создать ошибку `PHP Notice: Undefined
variable:foo` или `PHP Notice: Undefined index: bar`.

Это может показаться хорошей идеей, но есть несколько нежелательных компромиссов. PHP обрабатывает выражения, использующие
`@`, менее эффективно, чем выражения без `@`. Преждевременная оптимизация может быть корнем всех аргументов
программирования, но если производительность особенно важна для вашего приложения/библиотеки, важно понимать влияние
оператора контроля ошибок на производительность.

Во-вторых, оператор контроля ошибок **полностью** проглатывает ошибку. Ошибка не отображается, и ошибка не отправляется
в журнал ошибок. Кроме того, стандартные / производственные PHP-системы не имеют возможности отключить оператор контроля
ошибок. Хотя вы можете быть правы в том, что ошибка, которую вы видите, безобидна, другая, менее безобидная ошибка будет
такой же бесшумной.

Если есть способ избежать оператора подавления ошибок, вы должны рассмотреть его. Например, наш код выше можно было бы
переписать так:

{% highlight php %}
<?php
// Null Coalescing Operator
echo $foo['bar'] ?? '';
{% endhighlight %}

Один из случаев, когда подавление ошибок может иметь смысл, это когда `fopen()` не может найти файл для загрузки. Вы
можете проверить существование файла, прежде чем пытаться его загрузить, но если файл будет удален после проверки и до
`fopen()` (что может показаться невозможным, но это может случиться), тогда `fopen()` вернет false _и_ выдаст ошибку.
Этот потенциально это то, что PHP должен решить, но это один из случаев, когда подавление ошибок может показаться
единственным правильным решением.

Ранее мы упоминали, что в стандартной системе PHP нет возможности отключить оператор контроля ошибок. Однако [Xdebug]
имеет ini-настройку `xdebug.scream`, которая отключает оператор контроля ошибок. Вы можете установить это через файл
`php.ini` следующим образом.

{% highlight ini %}
xdebug.scream = On
{% endhighlight %}

Вы также можете установить это значение во время выполнения с помощью функции `ini_set`

{% highlight php %}
<?php
ini_set('xdebug.scream', '1')
{% endhighlight %}

PHP-расширение "[Scream]" предлагает функциональность, аналогичную расширению Xdebug, хотя параметр ini Scream
называется `scream.enabled`.

Это наиболее полезно, когда вы отлаживаете код и подозреваете, что информационная ошибка подавляется. Используйте scream
с осторожностью и как временный инструмент отладки. Есть много кода библиотеки PHP, который может не работать с
отключенным оператором контроля ошибок.

*[Error Control Operators]
* [SitePoint]
*[Xdebug]
* [Scream]

### ErrorException

PHP is perfectly capable of being an "exception-heavy" programming language, and only requires a few lines of code to
make the switch. Basically you can throw your "errors" as "exceptions" using the `ErrorException` class, which extends
the `Exception` class.

This is a common practice implemented by a large number of modern frameworks such as Symfony and Laravel. In debug
mode *(or dev mode)* both of these frameworks will display a nice and clean *stack trace*.

There are also some packages available for better error and exception handling and reporting. Like [Whoops!], which comes with the default installation of Laravel and can be used in any framework as well.

By throwing errors as exceptions in development you can handle them better than the usual result, and if you see an
exception during development you can wrap it in a catch statement with specific instructions on how to handle the
situation. Each exception you catch instantly makes your application that little bit more robust.

More information on this and details on how to use `ErrorException` with error handling can be found at
[ErrorException Class][errorexception].

*[Error Control Operators]
* [Predefined Constants for Error Handling]
*[`error_reporting()`][error_reporting]
* [Reporting][errorreport]

[errorreport]: /#error_reporting
[Xdebug]: https://xdebug.org/docs/basic
[Scream]: https://secure.php.net/book.scream
[Error Control Operators]: https://secure.php.net/language.operators.errorcontrol
[SitePoint]: https://www.sitepoint.com/
[Whoops!]: https://filp.github.io/whoops/
[errorexception]: https://secure.php.net/class.errorexception
[Predefined Constants for Error Handling]: https://secure.php.net/errorfunc.constants
[error_reporting]: https://secure.php.net/function.error-reporting
