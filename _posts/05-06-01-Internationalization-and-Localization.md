---
title:   Интернационализация и Локализация
isChild: true
anchor:  i18n_l10n
---

## Интернационализация (i18n) и Локализация (l10n) {#i18n_l10n_title}

_Предупреждение для новичков: i18n и l10n — это нумеронимы, своего рода аббревиатура, где числа используются для
сокращения слов — в нашем случае интернационализация становится i18n, а локализация — l10n._

Прежде всего, нам нужно определить эти два похожих понятия и другие связанные вещи:

- **Интернационализация** — это когда вы организуете свой код, чтобы его можно было адаптировать к различным языкам или регионам без
рефакторинга. Это действие обычно делается один раз - желательно в начале проекта, иначе вам, вероятно, потребуются какие-то огромные изменения в исходниках!
- **Локализация** происходит, когда вы адаптируете интерфейс (в основном) путем перевода содержимого на основе работы i18n, проделанной
ранее. Обычно это делается каждый раз, когда требуется поддержка нового языка или региона, и обновляется при добавлении новых частей интерфейса, поскольку они должны быть доступны на всех поддерживаемых языках.
- **Множественность** определяет правила, необходимые между разными языками для взаимодействия строк, содержащих числа и счетчики. Например,
в английском языке, когда у вас есть только один элемент, он стоит в единственном числе, а все, что отличается от него, называется множественным числом; множественное число в этом языке обозначается добавлением S после некоторых слов, а иногда и изменением его частей. В
других языках, таких как русский или сербский, есть две формы множественного числа в дополнение к форме единственного числа - вы даже можете
найти языки с четырьмя, пятью или шестью формами, например словенский, ирландский или арабский.

## Распространенные способы реализации

Самый простой способ интернационализировать софт PHP - это использование массива файлов и строк в шаблонах, таких как
`<h1><?=$TRANS['title_about_page']?></h1>`. Однако, этот способ, вряд ли рекомендован для серьезных проектов, так как это предполагает
некоторые проблемы в обслуживании на пути - некоторые могут появиться в самом начале, такие как
множественность.Так что, пожалуйста, не пробуйте это, если ваш проект будет состоять из более чем пары страниц.

Самый классический и часто используемый способ для i18n и l10n - это [Unix инструмент называющийся `gettext`][gettext]. Он берет своё начало
с 1995 и все еще является совершенной реализацией для перевода программного обеспечения. С ним достаточно легко начать работать, пока
все еще обладающий недюжинной силой, инструмент поддержки. О Gettext мы поговорим здесь. Так же , чтобы помочь вам не запутаться
в командной строке, мы представим замечательное GUI приложение которое может быть использовано для легкого обновления вашего l10n исходника

### Другие инструменты

Есть общеиспользуемые библиотеки которые поддерживают Gettext и другие реализации i18n. Некоторые из них могут показаться более простыми
в установке или поддержке дополнительных возможностей или i18n файловых форматов. В этом документе, мы фокусируемся на инструментах поставляемых с ядром PHP, но здесь, для полноты, мы перечислим и другие:

- [aura/intl][aura-intl]: Предоставляет инструменты интернационализации (I18N), специально пакетно-ориентированный перевод сообщений для каждой локали. Он использует форматы массива для сообщения. Не предоставляет экстрактор сообщения, но предоставляет расширенное форматирование сообщения через `intl` расширение (включая множественные сообщения).
- [oscarotero/Gettext][oscarotero]: поддержка Gettext с ОО интерфейсом; включая улучшенные вспомогательные функции, мощные экстракторы для некоторых форматов файла (некоторые из них изначально не поддерживаются командой `gettext`), а также экспорт
в другие форматы помимо `.mo/.po` файлов. Может быть полезно если нужно интегрировать ваши файлы перевода в другие
части системы, например JavaScript интерфейс.
- [symfony/translation][symfony]: поддерживает много разных форматов, но рекомендуется использовать многословный XLIFF. Не
включает вспомогательных функций а также встроенных экстракторов, но внутренне поддерживает заполнители используя `strtr()`.
- [laminas/laminas-i18n][laminas]: поддерживает массив и INI файлы, или Gettext форматы. Реализует уровень кеширования, чтобы избавить вас от необходимости чтения файловой системы, каждый раз. Также включает вспомогательные функции просмотра, входные фильтры с учетом локали и валидаторы.
Однако, не имеет экстракторов сообщения.

Другие фреймворки также включают в себя i18n модули, но они не доступны за пределами их кодовой базы:

- [Laravel] поддерживает вазовый массив файлов, не имеет автоматического экстрактора но включает вспомогательную функцию `@lang` для файлов шаблонов.
- [Yii] поддерживает массив, Gettext, перевод на основе базы данных, и включает экстрактор сообщений. Поддерживается
расширением [`Intl`][intl], доступным, начиная с PHP 5.3, и основанным на [ICU project]; это позволяет Yii выполнять
мощные замены, такие как прописывание чисел, форматирование дат, времени, интервалов, валюты и порядковых номеров.

Если вы решите использовать одну из библиотек, не предоставляющих экстракторов, вы можете использовать форматы
gettext, чтобы вы могли использовать исходную цепочку инструментов gettext (включая Poedit), как описано в оставшейся части главы.

## Gettext

### Установка

Возможно, вам потребуется установить Gettext и связанную с ним библиотеку PHP с помощью вашего менеджера пакетов, такого
как `apt-get` или `yum`. После установки включите его, добавив `extension=gettext.so` (Linux/Unix) или
`extension=php_gettext.dll` (Windows) в ваш `php.ini`.

Здесь мы также будем использовать [Poedit] для создания файлов перевода. Вы, вероятно, найдете его в менеджере пакетов
вашей системы; он доступен для Unix, Mac и Windows, а также может быть [бесплатно загружен на их веб-сайте][poedit_download].

### Структура

#### Типы файлов

Есть три файла, с которыми вы обычно имеете дело при работе с gettext. Основными из них являются файлы PO (Portable Object)
и MO (Machine Object), первый из которых представляет собой список читаемых «переведенных объектов», а второй — соответствующий
двоичный файл, который должен интерпретироваться gettext при выполнении локализации. Существует также файл POT (шаблон),
который просто содержит все существующие ключи из ваших исходных файлов и может использоваться в качестве руководства для
создания и обновления всех файлов PO. Эти файлы шаблонов не являются обязательными: в зависимости от инструмента, который
вы используете для выполнения l10n, вы вполне можете обойтись только файлами PO/MO. У вас всегда будет одна пара файлов
PO/MO для каждого языка и региона, но только одна POT для каждого домена.

### Домены

В некоторых случаях в больших проектах вам может понадобиться разделить переводы, когда одни и те же слова имеют разное
значение в зависимости от контекста. В этих случаях вы разделяете их на разные _домены_. По сути, это именованные группы
файлов POT/PO/MO, где имя файла является указанным _доменом перевода_. Малые и средние проекты обычно для простоты используют
только один домен; его имя произвольное, но мы будем использовать «main» для наших примеров кода. Например, в проектах
[Symfony] домены используются для разделения перевода сообщений проверки.

#### Locale коды

Locale - это просто код который идентифицирует версию одного языка. Это определено следующими [ISO 639-1][639-1] и
[ISO 3166-1 alpha-2][3166-1] спецификациями: две строчные буквы для языка, необязательно с последующим подчеркиванием и двумя
заглавными буквами обозначающими код страны или региона. Для [редких языков][rare], используются три буквы.

Для некоторых говорящих часть страны может показаться избыточной. На самом деле некоторые языки имеют диалекты в разных странах,
например, австрийский немецкий (`de_AT`) или бразильский португальский (`pt_BR`). Вторая часть используется для различия
этих диалектов - когда ее нет, она рассматривается как «общая» или «гибридная» версия языка.

### Структура каталогов

Чтобы использовать Gettext, нам нужно будет придерживаться определенной структуры папок. Во-первых, вам нужно будет выбрать
произвольный корень для ваших файлов l10n в исходном репозитории. Внутри у вас будет папка для каждой необходимой локали
и фиксированная папка LC_MESSAGES, которая будет содержать все ваши пары PO/MO. Пример:

{% highlight console %}
<project root>
 ├─ src/
 ├─ templates/
 └─ locales/
    ├─ forum.pot
    ├─ site.pot
    ├─ de/
    │  └─ LC_MESSAGES/
    │     ├─ forum.mo
    │     ├─ forum.po
    │     ├─ site.mo
    │     └─ site.po
    ├─ es_ES/
    │  └─ LC_MESSAGES/
    │     └─ ...
    ├─ fr/
    │  └─ ...
    ├─ pt_BR/
    │  └─ ...
    └─ pt_PT/
       └─ ...
{% endhighlight %}

### Множественные формы

Как мы уже говорили во введении, разные языки могут иметь разные правила множественного числа. Однако gettext в очередной
раз спасает нас от этой неприятности. При создании нового файла `.po` вам нужно будет объявить [правила множественного числа][plural]
для этого языка, и переведенные части, чувствительные к множественному числу, будут иметь другую форму для каждого из этих правил.
При вызове Gettext в коде вам нужно будет указать номер, относящийся к предложению, и он выработает правильную форму для использования -
даже с использованием подстановки строк, если это необходимо.

Правила множественного числа включают в себя количество доступных множественных чисел и логическую проверку с `n`,
которая определяет, в какое правило попадает данное число (начиная с 0). Например:

- Japanese: `nplurals=1; plural=0` - только одно правило
- English: `nplurals=2; plural=(n != 1);` - два правила, первое - если N единица, второе правило - в противном случае
- Brazilian Portuguese: `nplurals=2; plural=(n > 1);` - два правила, второе - если N больше одного, первое - в противном случае

Теперь, когда вы поняли, как работают правила множественного числа, а если нет, ознакомьтесь с более подробным объяснением
в [учебнике LingoHub][lingohub_plurals], вы можете скопировать те, которые вам нужны, из [списка][plural] вместо того,
чтобы писать их от руки.

При вызове Gettext для локализации предложений со счетчиками вам также нужно будет указать соответствующий номер. Gettext
определит, какое правило должно действовать, и использует правильную локализованную версию. Вам нужно будет включить
в файл `.po` разные предложения для каждого определенного правила множественного числа.

### Пример реализации

После всей этой теории давайте перейдем к практике. Вот выдержка из файла `.po` - не обращайте внимания на его формат,
но вместо этого обратите внимание на общее содержание; позже вы научитесь легко его редактировать:

{% highlight po %}
msgid ""
msgstr ""
"Language: pt_BR\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

msgid "We are now translating some strings"
msgstr "Nós estamos traduzindo algumas strings agora"

msgid "Hello %1$s! Your last visit was on %2$s"
msgstr "Olá %1$s! Sua última visita foi em %2$s"

msgid "Only one unread message"
msgid_plural "%d unread messages"
msgstr[0] "Só uma mensagem não lida"
msgstr[1] "%d mensagens não lidas"
{% endhighlight %}

Первая секция работает как заголовок, имея пустые поля `msgid` и `msgstr`. В нем описывается кодировка файла,
формы множественного числа и другие менее важные вещи.
Второй раздел переводит простую строку с английского на
бразильский португальский, а третий делает то же самое, но использует замену строки из [`sprintf`][sprintf], поэтому
перевод может содержать имя пользователя и дату посещения.
Последний раздел представляет собой пример форм множественного числа, отображающих
версию единственного и множественного числа как `msgid` на английском языке и их соответствующие переводы как `msgstr` 0 и 1
(после числа, заданного правилом множественного числа). Там также используется замена строки, поэтому номер можно увидеть
прямо в предложении, используя `%d`. Формы множественного числа всегда имеют два `msgid` (единственное и множественное число), поэтому
рекомендуется не использовать сложный язык в качестве источника перевода.

### Обсуждение l10n ключей

Как вы могли заметить, мы используем в качестве идентификатора источника фактическое предложение на английском языке.
Этот `msgid` используется во всех ваших файлах `.po`, что означает, что другие языки будут иметь тот же формат и те же
поля `msgid`, но переведенные строки `msgstr`.

Говоря о ключах перевода, здесь есть две основные «школы»:

1. _`msgid` как настоящее предложение_.
    Основные преимущества:

    - если есть части программного обеспечения, не переведенные на какой-либо язык, отображаемый ключ все равно будет иметь какое-то значение. Пример: если вы переводите наизусть с английского на испанский, но вам нужна помощь в переводе на французский,
    вы можете опубликовать новую страницу с отсутствующими французскими предложениями, и вместо этого части веб-сайта
    будут отображаться на английском языке;
    - переводчику намного легче понять, что происходит, и сделать правильный перевод на основе `msgid`;
    - оно дает вам "бесплатный" l10n для одного языка - исходного;
    - Единственный недостаток: если вам нужно изменить фактический текст, вам нужно будет заменить один и тот же `msgid`
    в нескольких языковых файлах.

2. _`msgid` как уникальный, структурированный ключ_.
Он будет структурированно описывать роль предложения в приложении, включая шаблон или часть, в которой находится строка,
а не ее содержимое.
    - это отличный способ организовать код, отделив текстовое содержимое от логики шаблона.
    - однако это может создать проблемы для переводчика, который упустит контекст. Файл исходного языка потребуется
    в качестве основы для других переводов. Пример: в идеале у разработчика должен быть файл `en.po`, который
    переводчики будут читать, чтобы понять, что писать, например, в `fr.po`.
    - отсутствующие переводы будут отображать бессмысленные клавиши на экране (`top_menu.welcome` вместо `Привет, пользователь!`
    на указанной непереведенной французской странице). Это хорошо, поскольку заставило бы перевод быть завершенным перед публикацией,
    но плохо, поскольку проблемы с переводом были бы ужасно ужасными в интерфейсе. Некоторые библиотеки, тем не менее, включают
    возможность указать данный язык как "резервный", имея поведение, аналогичное другому подходу.

В [руководстве по Gettext][manual] предпочтение отдается первому подходу, так как в целом он проще для переводчиков и пользователей в
случае возникновения проблем. Так же и здесь будем работать. Тем не менее, [документация Symfony][symfony-keys] отдает предпочтение
переводу на основе ключевых слов, что позволяет вносить независимые изменения во все переводы, не затрагивая при этом шаблоны.

### Повседневное использование

В типичном приложении вы должны использовать некоторые функции Gettext при написании статического текста на своих страницах. Затем эти
предложения появляются в файлах `.po`, переводятся, компилируются в файлы `.mo` и затем используются Gettext при рендеринге
фактического интерфейса. Учитывая это, давайте свяжем то, что мы обсуждали до сих пор, в пошаговом примере:

#### 1. Пример файла шаблона, включающего несколько различных вызовов gettext

{% highlight php %}
<?php include 'i18n_setup.php' ?>
<div id="header">
    <h1><?=sprintf(gettext('Welcome, %s!'), $name)?></h1>
    <!-- code indented this way only for legibility -->
    <?php if ($unread): ?>
        <h2><?=sprintf(
            ngettext('Only one unread message',
                     '%d unread messages',
                     $unread),
            $unread)?>
        </h2>
    <?php endif ?>
</div>

<h1><?=gettext('Introduction')?></h1>
<p><?=gettext('We\'re now translating some strings')?></p>
{% endhighlight %}

- [`gettext()`][func] просто переводит `msgid` в соответствующий `msgstr` для данного языка. Есть также
короткая функция `_()` которая работает точно так же;
- [`ngettext()`][n_func] делает то же самое, но с правилами множественного числа;
- есть также [`dgettext()`][d_func] и [`dngettext()`][dn_func], что позволяют переопределить домен для одного
вызова. Подробнее о конфигурации домена в следующем примере.

#### 2. Образец установочного файла (`i18n_setup.php`, как указано выше), выбор правильной локали и настройка Gettext

{% highlight php %}
<?php
/**
 * Verifies if the given $locale is supported in the project
 * @param string $locale
 * @return bool
 */
function valid($locale) {
   return in_array($locale, ['en_US', 'en', 'pt_BR', 'pt', 'es_ES', 'es']);
}

//setting the source/default locale, for informational purposes
$lang = 'en_US';

if (isset($_GET['lang']) && valid($_GET['lang'])) {
    // the locale can be changed through the query-string
    $lang = $_GET['lang'];    //you should sanitize this!
    setcookie('lang', $lang); //it's stored in a cookie so it can be reused
} elseif (isset($_COOKIE['lang']) && valid($_COOKIE['lang'])) {
    // if the cookie is present instead, let's just keep it
    $lang = $_COOKIE['lang']; //you should sanitize this!
} elseif (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
    // default: look for the languages the browser says the user accepts
    $langs = explode(',', $_SERVER['HTTP_ACCEPT_LANGUAGE']);
    array_walk($langs, function (&$lang) { $lang = strtr(strtok($lang, ';'), ['-' => '_']); });
    foreach ($langs as $browser_lang) {
        if (valid($browser_lang)) {
            $lang = $browser_lang;
            break;
        }
    }
}

// here we define the global system locale given the found language
putenv("LANG=$lang");

// this might be useful for date functions (LC_TIME) or money formatting (LC_MONETARY), for instance
setlocale(LC_ALL, $lang);

// this will make Gettext look for ../locales/<lang>/LC_MESSAGES/main.mo
bindtextdomain('main', '../locales');

// indicates in what encoding the file should be read
bind_textdomain_codeset('main', 'UTF-8');

// if your application has additional domains, as cited before, you should bind them here as well
bindtextdomain('forum', '../locales');
bind_textdomain_codeset('forum', 'UTF-8');

// here we indicate the default domain the gettext() calls will respond to
textdomain('main');

// this would look for the string in forum.mo instead of main.mo
// echo dgettext('forum', 'Welcome back!');
?>
{% endhighlight %}

#### 3. Подготовка перевода к первому запуску

Одним из больших преимуществ Gettext по сравнению с настраиваемыми пакетами i18n является обширный и мощный формат файлов.
"О, чувак, это довольно сложно понять и отредактировать вручную, простой массив был бы проще!" Не заблуждайтесь,
такие приложения, как [Poedit], здесь, чтобы помочь - _много_. Вы можете скачать программу с [их веб-сайта][poedit_download],
она бесплатна и доступна для всех платформ. Это довольно простой инструмент, к которому можно привыкнуть, и в то же
время очень мощный — он использует все функции, доступные в Gettext. Это руководство основано на PoEdit 1.8.

При первом запуске вы должны выбрать "File > New..." из меню. Вам сразу же будет предложено выбрать язык:
здесь вы можете выбрать/отфильтровать язык, на который хотите перевести, или использовать тот формат, который мы упоминали ранее, например
`en_US` или `pt_BR`.

Теперь сохраните файл, используя ту же структуру каталогов, о которой мы упоминали. Затем вы должны нажать "Extract from sources",
и здесь вы настроите различные параметры для задач извлечения и перевода. Вы сможете найти все это
позже через "Catalog > Properties":

- Source paths: здесь вы должны включить все папки из проекта, где вызывается `gettext()` (и родственные) - обычно это ваши
папки шаблонов/представлений. Это единственная обязательная настройка;
- Translation properties:
  - Project name and version, Team and Team’s email address: полезная информация, которая находится в заголовке файла .po;
  - Plural forms: вот и те правила, о которых мы упоминали ранее — там также есть ссылка с образцами. В большинстве случаев
  вы можете оставить его с параметром по умолчанию, поскольку PoEdit уже включает удобную базу данных множественных
  правил для многих языков.
  - Charsets: UTF-8, желательно;
  - Source code charset: установите здесь кодировку, используемую вашей кодовой базой - возможно, UTF-8, верно?
- Source keywords: Базовое программное обеспечение знает, как `gettext()` и подобные вызовы функций выглядят в нескольких
языках программирования, но вы также можете создавать свои собственные функции перевода. Именно здесь вы добавите эти
другие методы. Об этом позже в разделе "Советы".

После установки этих точек он просканирует ваши исходные файлы, чтобы найти все вызовы локализации. После каждого
сканирования PoEdit будет отображать сводку того, что было найдено и что было удалено из исходных файлов. Новые записи будут
загружены в таблицу перевода пустыми, и вы начнете вводить локализованные версии этих строк. Сохраните его, и файл .mo
будет (повторно)скомпилирован в ту же папку и та-да: ваш проект интернационализирован.

#### 4. Перевод строк

Как вы, возможно, уже заметили, есть два основных типа локализованных строк: простые и во множественном числе.
Первые имеют просто два поля: исходную и локализованную строку. Исходная строка не может быть изменена, так как
Gettext/Poedit не имеет права изменять ваши исходные файлы - вам следует изменить сам источник и повторно отсканировать
файлы. Совет: вы можете щелкнуть правой кнопкой мыши строку перевода, и она подскажет вам исходные файлы и строки,
в которых используется эта строка.
С другой стороны, строки во множественном числе включают в себя два поля для отображения двух исходных строк и вкладки,
позволяющие настраивать различные окончательные формы.

Всякий раз, когда вы изменяете свои источники и вам нужно обновить переводы, просто нажмите Refresh, и Poedit повторно
просканирует код, удалив несуществующие записи, объединив те, которые были изменены, и добавив новые. Он также может попытаться угадать
некоторые переводы, основываясь на других сделанных вами переводах. Эти предположения и измененные записи получат маркер "Fuzzy",
указывающий на то, что они нуждаются в проверке, и отобразятся в списке золотыми. Это также полезно, если у вас есть команда
переводчиков, и кто-то пытается написать что-то, в чем он не уверен: просто отметьте Fuzzy, и кто-то другой проверит позже.

Наконец, рекомендуется оставить отмеченным "View > Untranslated entries first", так как это поможет вам _много_ не забыть,
ни одной записи. Из этого меню вы также можете открывать части пользовательского интерфейса, которые позволяют
при необходимости оставлять контекстную информацию для переводчиков.

### Tips & Tricks

#### Возможные проблемы с кэшированием

If you are running PHP as a module on Apache (`mod_php`), you might face issues with the `.mo` file being cached. It
happens the first time it is read, and then, to update it, you might need to restart the server. On Nginx and PHP5 it
usually takes only a couple of page refreshes to refresh the translation cache, and on PHP7 it is rarely needed.

#### Additional helper functions

As preferred by many people, it is easier to use `_()` instead of `gettext()`. Many custom i18n libraries from
frameworks use something similar to `t()` as well, to make translated code shorter. However, that is the only function
that sports a shortcut. You might want to add in your project some others, such as `__()` or `_n()` for `ngettext()`,
or maybe a fancy `_r()` that would join `gettext()` and `sprintf()` calls. Other libraries, such as
[oscarotero's Gettext][oscarotero] also provide helper functions like these.

In those cases, you'll need to instruct the Gettext utility on how to extract the strings from those new functions.
Don't be afraid; it is very easy. It is just a field in the `.po` file, or a Settings screen on Poedit. In the editor,
that option is inside "Catalog > Properties > Source keywords". Remember: Gettext already knows the default functions
for many languages, so don’t be afraid if that list seems empty. You need to include there the specifications of those
new functions, following [a specific format][func_format]:

- if you create something like `t()` that simply returns the translation for a string, you can specify it as `t`.
Gettext will know the only function argument is the string to be translated;
- if the function has more than one argument, you can specify in which one the first string is - and if needed, the
plural form as well. For instance, if we call our function like this: `__('one user', '%d users', $number)`, the
specification would be `__:1,2`, meaning the first form is the first argument, and the second form is the second
argument. If your number comes as the first argument instead, the spec would be `__:2,3`, indicating the first form is
the second argument, and so on.

After including those new rules in the `.po` file, a new scan will bring in your new strings just as easy as before.

### References

- [Wikipedia: i18n and l10n](https://en.wikipedia.org/wiki/Internationalization_and_localization)
- [Wikipedia: Gettext](https://en.wikipedia.org/wiki/Gettext)
- [LingoHub: PHP internationalization with gettext tutorial][lingohub]
- [PHP Manual: Gettext](https://secure.php.net/manual/book.gettext.php)
- [Gettext Manual][manual]

[Poedit]: https://poedit.net
[poedit_download]: https://poedit.net/download
[lingohub]: https://lingohub.com/blog/2013/07/php-internationalization-with-gettext-tutorial/
[lingohub_plurals]: https://lingohub.com/blog/2013/07/php-internationalization-with-gettext-tutorial/#Plurals
[plural]: http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html
[gettext]: https://en.wikipedia.org/wiki/Gettext
[manual]: https://www.gnu.org/software/gettext/manual/gettext.html
[639-1]: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
[3166-1]: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
[rare]: https://www.gnu.org/software/gettext/manual/gettext.html#Rare-Language-Codes
[func_format]: https://www.gnu.org/software/gettext/manual/gettext.html#Language-specific-options
[aura-intl]: https://github.com/auraphp/Aura.Intl
[oscarotero]: https://github.com/oscarotero/Gettext
[symfony]: https://symfony.com/doc/current/components/translation.html
[laminas]: https://docs.laminas.dev/laminas-i18n/
[laravel]: https://laravel.com/docs/master/localization
[yii]: https://www.yiiframework.com/doc/guide/2.0/en/tutorial-i18n
[intl]: https://secure.php.net/manual/intro.intl.php
[ICU project]: http://www.icu-project.org
[symfony-keys]: https://symfony.com/doc/current/components/translation/usage.html#creating-translations

[sprintf]: https://secure.php.net/manual/function.sprintf.php
[func]: https://secure.php.net/manual/function.gettext.php
[n_func]: https://secure.php.net/manual/function.ngettext.php
[d_func]: https://secure.php.net/manual/function.dgettext.php
[dn_func]: https://secure.php.net/manual/function.dngettext.php
