---
isChild: true
title: Ошибки
anchor:  errors
---

## Ошибки {#errors_title}

Во многих языках программирования с большим количеством исключений всякий раз, когда что-то пойдет не так, будет выдано
исключение. Это, безусловно, жизнеспособный способ сделать что-то, но PHP — это язык программирования с "легким
исключением". Хотя у него есть исключения, и большая часть ядра начинает использовать их при работе с объектами, большая
часть самого PHP будет пытаться продолжать обработку независимо от того, что происходит, если только не произойдет
фатальная ошибка.

Например:

{% highlight console %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

Это всего лишь ошибка уведомления, и PHP с радостью продолжит работу. Это может сбивать с толку тех, кто работает с
языками с "тяжелыми исключениями", потому что, например, ссылка на отсутствующую переменную в Python вызовет исключение:

{% highlight console %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

Единственная реальная разница в том, что Python сходит с ума из-за любой мелочи, так что разработчики могут быть уверены,
что любая потенциальная проблема или пограничный случай обнаружены, в то время как PHP продолжит обработку, если не
произойдет что-то экстремальное, и в этот момент он выдаст ошибку. ошибка и сообщите об этом.

### Серьезность ошибки

PHP имеет несколько уровней серьезности ошибок. Тремя наиболее распространенными типами сообщений являются ошибки,
уведомления и предупреждения. Они имеют разные уровни серьезности; `E_ERROR`, `E_NOTICE` и `E_WARNING`. Ошибки — это
фатальные ошибки во время выполнения, обычно они вызваны ошибками в вашем коде и должны быть исправлены, поскольку они
приводят к остановке выполнения PHP. Уведомления — это консультативные сообщения, вызванные кодом, который может вызывать
или не вызывать проблемы во время выполнения скрипта, выполнение не останавливается. Предупреждения являются не фатальными
ошибками, выполнение скрипта не будет остановлено.

Другим типом сообщений об ошибках, сообщаемых во время компиляции, являются сообщения `E_STRICT`. Эти сообщения
используются для предложения изменений в вашем коде, чтобы обеспечить наилучшее взаимодействие и совместимость с будущими
версиями PHP.

### Изменение поведения отчетов об ошибках PHP

Изменение поведения отчетов об ошибках PHP Отчеты об ошибках можно изменить с помощью настроек PHP и/или вызовов функций
PHP. Используя встроенную функцию PHP `error_reporting()`, вы можете установить уровень ошибок на время выполнения
скрипта, передав одну из предопределенных констант уровня ошибок, что означает, что если вы хотите видеть только ошибки
и предупреждения, но не уведомления - то вы можете настроить это:

{% highlight php %}
<?php
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

Вы также можете контролировать, будут ли ошибки отображаться на экране (удобно для разработки) или скрыты и
зарегистрированы (удобно для производства). Дополнительную информацию об этом можно найти в разделе [Отчеты об ошибках]
[errorreport].

### Встроенное подавление ошибок

Вы также можете указать PHP подавлять определенные ошибки с помощью оператора контроля ошибок `@`. Вы помещаете этот
оператор в начало выражения, и любая ошибка, являющаяся прямым результатом выражения, замалчивается.

{% highlight php %}
<?php
echo @$foo['bar'];
{% endhighlight %}

Это выведет `$foo['bar']`, если он существует, но просто вернет null и ничего не напечатает, если переменная `$foo` или
ключ `'bar'` не существует. Без оператора контроля ошибок это выражение могло бы создать ошибку `PHP Notice: Undefined
variable:foo` или `PHP Notice: Undefined index: bar`.

Это может показаться хорошей идеей, но есть несколько нежелательных компромиссов. PHP обрабатывает выражения, использующие
`@`, менее эффективно, чем выражения без `@`. Преждевременная оптимизация может быть корнем всех аргументов
программирования, но если производительность особенно важна для вашего приложения/библиотеки, важно понимать влияние
оператора контроля ошибок на производительность.

Во-вторых, оператор контроля ошибок **полностью** проглатывает ошибку. Ошибка не отображается, и ошибка не отправляется
в журнал ошибок. Кроме того, стандартные / производственные PHP-системы не имеют возможности отключить оператор контроля
ошибок. Хотя вы можете быть правы в том, что ошибка, которую вы видите, безобидна, другая, менее безобидная ошибка будет
такой же бесшумной.

Если есть способ избежать оператора подавления ошибок, вы должны рассмотреть его. Например, наш код выше можно было бы
переписать так:

{% highlight php %}
<?php
// Null Coalescing Operator
echo $foo['bar'] ?? '';
{% endhighlight %}

Один из случаев, когда подавление ошибок может иметь смысл, это когда `fopen()` не может найти файл для загрузки. Вы
можете проверить существование файла, прежде чем пытаться его загрузить, но если файл будет удален после проверки и до
`fopen()` (что может показаться невозможным, но это может случиться), тогда `fopen()` вернет false _и_ выдаст ошибку.
Этот потенциально это то, что PHP должен решить, но это один из случаев, когда подавление ошибок может показаться
единственным правильным решением.

Ранее мы упоминали, что в стандартной системе PHP нет возможности отключить оператор контроля ошибок. Однако [Xdebug]
имеет ini-настройку `xdebug.scream`, которая отключает оператор контроля ошибок. Вы можете установить это через файл
`php.ini` следующим образом.

{% highlight ini %}
xdebug.scream = On
{% endhighlight %}

Вы также можете установить это значение во время выполнения с помощью функции `ini_set`

{% highlight php %}
<?php
ini_set('xdebug.scream', '1')
{% endhighlight %}

Это наиболее полезно, когда вы отлаживаете код и подозреваете, что информационная ошибка подавляется. Используйте scream
с осторожностью и как временный инструмент отладки. Есть много кода библиотеки PHP, который может не работать с отключенным оператором контроля ошибок.

*[Error Control Operators]
* [SitePoint]
*[Xdebug]
* [Scream]

### ErrorException

PHP способен быть "насыщенным исключениями" языком  программирования, и для переключения требуется всего несколько строк
кода. В основном вы можете бросать ваши "ошибки" как "исключения" используя класс `ErrorException`, который расширяет
класс `Exception`.

Эта общая практика реализована большим количеством современных фреймворков, таких как Symfony и Laravel. В режиме отладки
*(или режиме разработки)* оба этих фреймворка будут отображать хорошие и понятные *трассировки стека*.

Также есть несколько доступных пакетов для улучшенной обработки и отчетности ошибок и исключений. Как [Whoops!], который
идет вместе с установкой Laravel по-умолчанию, и может быть использован вообще с любым фреймворком.

Выкидывая ошибки как исключения при разработке, вы можете обрабатывать их лучше чем обычной ситуации, и если вы видите
исключение во время разработки, вы можете оборачивать его в конструкцию catch с определенными инструкциями о том как
обработать ситуацию. Каждое исключение которое вы мгновенно отлавливаете, делает ваше приложение немного более надежным.

Больше подробной информации об этом и о том как использовать `ErrorException` для обработки ошибок можно найти по ссылкам
[ErrorException Class][errorexception].

*[Error Control Operators]
* [Predefined Constants for Error Handling]
*[`error_reporting()`][error_reporting]
* [Reporting][errorreport]

[errorreport]: {{site.baseurl}}/#error_reporting
[Xdebug]: https://xdebug.org/docs/basic
[Error Control Operators]: https://www.php.net/language.operators.errorcontrol
[SitePoint]: https://www.sitepoint.com/
[Whoops!]: https://filp.github.io/whoops/
[errorexception]: https://www.php.net/class.errorexception
[Predefined Constants for Error Handling]: https://www.php.net/errorfunc.constants
[error_reporting]: https://www.php.net/function.error-reporting
